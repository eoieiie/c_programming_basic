// can the following cide ever lead to an  infinite loop? Explain.
// (Assume that the values of i and j are not changed in the body of the loop.) 

// printf("Input two integers: ");
// seanf("%d%d", &i, &j);
// while (i  * j < 0 && ++ i ! = 7 && j ++ ! = 9)
// {}
/* do something */



// 이 코드는 무한 루프에 빠질 수 없습니다. 왜냐하면 i와 j가 각각 7과 9에 도달하면 반복문이 종료되기 때문입니다.

// 반복문의 조건은 세 부분으로 구성되어 있습니다: i * j < 0, ++i != 7, 그리고 j++ != 9. 이 세 조건 중 어느 하나라도 거짓이 되면, while 문은 종료됩니다.

// 첫 번째 조건(i * j < 0)은 i와 j 중 하나가 음수이고 다른 하나가 양수일 때만 참입니다.
// 두 번째 조건(++i != 7)은 전위 증가 연산자를 사용하여, 비교하기 전에 변수 i의 값을 증가시킵니다. 따라서 i의 값이 6일 때, 이 연산을 수행하면 i는 증가하여 값이 7이 되고, 이 부분의 결과는 거짓(false)가 됩니다.
// 세 번째 조건(j++ != 9)은 후위 증가 연산자를 사용합니다. 이것은 변수 j를 비교한 후에 값을 증가시킵니다. 따라서 j의 값이 이미 9일 경우, 이 부분의 결과는 거짓(false)입니다.
// 따라서 모든 경우에서 반복문은 결국 종료될 것입니다. 첫 번째 조건에서 양수와 음수의 곱셈 결과는 항상 음수입니다. 만약 계속해서 곱셈 결과가 음수인 상태를 유지하려면, 한 숫자는 양수로 유지되고 다른 숫자는 음수로 유지되어야 합니다. 그러나 두 번째 및 세 번째 조건에서 우리는 i와 j값을 계속 증가시키므로 결국에는 곱셈 결과도 양수 혹은 제로(zero)로 변화할 것입니다.

// 따라서 위 코드에서 while 문은 결코 무한루프에 빠지지 않습니다.

// 1.++ i 와 j ++ - 전위 및 후위 증감에 의해 i와 j 값이 각각 증가
// 2.i * j < 0 - 곱셈과 관계 비교
// 3.++ i != 7 와 j ++ != 9 - 동등성 검사
// 4.(i * j < 0) && (++ i != 7) && (j ++ != 9) -논리 AND




// ++i와 i++가 동시에 한 식에서 존재한다면, 그들의 계산 순서는 식에서의 위치와 
// 해당 언어의 연산자 우선순위 및 결합성에 따라 달라집니다.
// 예를 들어, C/C++과 같은 언어에서는 왼쪽에서 오른쪽으로 평가됩니다. 
// 따라서 ++i가 먼저 나오면 i는 먼저 증가하고, 그 다음에 i++가 평가되므로 이후에 i 값이 증가합니다.